{
  "version": 3,
  "sources": ["../../episodes/TBD01-lambda-substitution/index.ts", "../../episodes/TBD01-lambda-substitution/classicNamedCalculus.ts", "../../episodes/TBD01-lambda-substitution/test/variableCapture.test.ts"],
  "sourcesContent": ["// import demo from \"./demo\";\r\n// import \"./test/lambdaExp.test\";\r\nimport \"./test/variableCapture.test\";\r\nexport { lam } from \"./classicNamedCalculus\";\r\n\r\nexport type {\r\n    LambdaExpr,\r\n    Variable,\r\n    Application,\r\n    Abstraction,\r\n    BaseLambda,\r\n} from \"./classicNamedCalculus\";\r\n\r\n// demo();\r\n", "//New as of May 17 2023\r\n\r\n/// Circular reference bug. I don't understand why it worked before and not now? Was it just the extra level of indirection in the type definitions?\r\nexport type LambdaExpr = Abstraction | Variable | Application;\r\n\r\n// export type LambdaChildren<L extends LambdaExpr[] = LambdaExpr[]> = L\r\nexport type LambdaChild<L extends LambdaExpr = LambdaExpr> = L;\r\n\r\nexport type BaseLambda<Meta extends {}> = {\r\n    syntax: string; // Indicates the kind of syntax represented by the object\r\n} & Meta; // Pass in metalanguage info which can be used to add types, etc.;\r\n\r\nexport type Variable<Meta extends {} = {}> = BaseLambda<{\r\n    syntax: \"variable\";\r\n    name: string;\r\n    // children: never[] & LambdaChild[];\r\n}> &\r\n    Meta;\r\n\r\nexport type Abstraction<Meta extends {} = {}> = BaseLambda<{\r\n    syntax: \"abstraction\";\r\n    boundVar: Variable;\r\n    body: LambdaChild;\r\n    // children: [LambdaChild];\r\n}> &\r\n    Meta;\r\n\r\nexport type Application<Meta extends {} = {}> = BaseLambda<{\r\n    syntax: \"application\";\r\n    func: LambdaChild;\r\n    arg: LambdaChild;\r\n    // children: [LambdaChild, LambdaChild];\r\n}> &\r\n    Meta;\r\n\r\nexport const isVar = (x: LambdaExpr): x is Variable => {\r\n    if (x.syntax === \"variable\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nexport const isAbs = (x: LambdaExpr): x is Abstraction => {\r\n    if (x.syntax === \"abstraction\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nexport const isApp = (x: LambdaExpr): x is Application => {\r\n    if (x.syntax === \"application\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nlet regexEndsWithVarNumber = /_\\d+$/;\r\n\r\n//Constructs a free variable\r\n//By default it cannot end with an underscore followed by numbers.\r\nexport const Var = (name: string, numberingAllowed = false): Variable => {\r\n    if (\r\n        !numberingAllowed &&\r\n        regexEndsWithVarNumber.test(name) &&\r\n        name.endsWith(\"_\")\r\n    ) {\r\n        throw Error(\r\n            `You tried to create a new variable with a disallowed name: ${name}`\r\n        );\r\n    }\r\n\r\n    return {\r\n        syntax: \"variable\",\r\n        name,\r\n        // children: [],\r\n    };\r\n};\r\n\r\nconst deduplicateVariables = (vars: Variable[]) => {\r\n    const obj: { [x in string]: Variable } = {};\r\n    vars.forEach((v) => (obj[v.name] = v));\r\n    return Object.values(obj);\r\n};\r\n\r\nexport const excludeVariables = (\r\n    varList: Variable[],\r\n    varsToRemove: Variable[]\r\n) => {\r\n    const toRemoveNames: Set<string> = new Set();\r\n    varsToRemove.forEach((v) => toRemoveNames.add(v.name));\r\n    return varList.filter((v) => !toRemoveNames.has(v.name));\r\n};\r\n\r\nconst getFreeVars = (lambda: LambdaExpr): Variable[] => {\r\n    if (isVar(lambda)) {\r\n        return [lambda];\r\n    } else if (isAbs(lambda)) {\r\n        const { boundVar } = lambda;\r\n\r\n        //All free in the body of the abstraction are free in the abstraction except the bound variable\r\n        const body = lambda.body;\r\n\r\n        return excludeVariables(getFreeVars(body), [boundVar]);\r\n    } else if (isApp(lambda)) {\r\n        const [func, arg] = appBranches(lambda);\r\n\r\n        return deduplicateVariables([\r\n            ...getFreeVars(func),\r\n            ...getFreeVars(arg),\r\n        ]);\r\n    }\r\n    let x: never = lambda;\r\n    return lambda;\r\n};\r\n\r\nexport const getBoundVars = (child: LambdaExpr): Variable[] => {\r\n    if (isVar(child)) {\r\n        return [];\r\n    } else if (isAbs(child)) {\r\n        const { boundVar } = child;\r\n\r\n        return deduplicateVariables([boundVar, ...getBoundVars(child.body)]);\r\n    } else if (isApp(child)) {\r\n        const [func, arg] = appBranches(child);\r\n\r\n        const funcVars = getBoundVars(func);\r\n        const argVars = getBoundVars(arg);\r\n\r\n        return deduplicateVariables([...funcVars, ...argVars]);\r\n    }\r\n    let x: never = child;\r\n    return child;\r\n};\r\n\r\nexport const abstraction = (\r\n    variable: Variable,\r\n    lambda: LambdaExpr\r\n): Abstraction => {\r\n    return {\r\n        syntax: \"abstraction\",\r\n        boundVar: variable,\r\n        body: lambda,\r\n        // children: [lambda],\r\n    };\r\n};\r\n\r\nexport const application = (\r\n    first: LambdaExpr,\r\n    second: LambdaExpr\r\n): Application => {\r\n    return {\r\n        syntax: \"application\",\r\n        func: first,\r\n        arg: second,\r\n        // children: [first, second],\r\n    };\r\n};\r\n\r\nexport type LambdaMethods<Return, Args extends unknown[]> = {\r\n    variable: (\r\n        x: Variable,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n    application: (\r\n        x: Application,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n    abstraction: (\r\n        x: Abstraction,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n};\r\n\r\n//<I extends LambdaExpr, R extends LambdaExpr>\r\nconst mkLambdaFn =\r\n    <Return, Args extends unknown[]>(fns: LambdaMethods<Return, Args>) =>\r\n    (lambda: LambdaExpr, ...args: Args) => {\r\n        const inner = (lambda: LambdaExpr, ...innerArgs: Args | []): Return => {\r\n            const extraArgs = (innerArgs.length ? innerArgs : args) as Args;\r\n\r\n            if (isVar(lambda)) {\r\n                return fns.variable(lambda, inner, ...extraArgs);\r\n            } else if (isApp(lambda)) {\r\n                return fns.application(lambda, inner, ...extraArgs);\r\n            } else if (isAbs(lambda)) {\r\n                return fns.abstraction(lambda, inner, ...extraArgs);\r\n            }\r\n            let x: never = lambda;\r\n            return lambda;\r\n        };\r\n\r\n        return inner(lambda);\r\n    };\r\n\r\nexport const lambdaToStringMethods: LambdaMethods<string, []> = {\r\n    variable: (variable) => {\r\n        return variable.name;\r\n    },\r\n    abstraction: (abs, inner) => {\r\n        const body = abs.body;\r\n        const bodyStr = inner(body);\r\n\r\n        return `\u03BB(${inner(abs.boundVar)}).[${bodyStr}]`;\r\n    },\r\n    application: (app, inner) => {\r\n        return `(${inner(app.func)})(${inner(app.arg)})`;\r\n    },\r\n};\r\n\r\nexport const lambdaToString = mkLambdaFn(lambdaToStringMethods);\r\n\r\nexport const printExpr = (lambdaExp: LambdaExpr) => {\r\n    // console.log(\"\\n\");\r\n    console.log(lambdaToString(lambdaExp));\r\n};\r\n\r\nexport const childFVToString = (childExpr: LambdaExpr) => {\r\n    return getFreeVars(childExpr)\r\n        .map((v) => lambdaToString(v))\r\n        .join(\", \");\r\n};\r\n\r\n// export const childFVsToString = mkLambdaFn(\r\n//     {\r\n//         variable (x) {\r\n//             return []\r\n//         },\r\n//         abstraction(abs, inner) {\r\n//             inner(abs.body)\r\n//         },\r\n//         application(app, inner) {\r\n//             const {func, arg} = app\r\n//             return inner(func) + inner(arg)\r\n//         }\r\n\r\n//     }\r\n\r\n// .map(\r\n//     (c, i) => (i > 0 ? \"\\n\" : \"\") + `child ${i}: ` + childFVToString(c)\r\n// )\r\n// .join(\"\");\r\n// };\r\n\r\n// )\r\n\r\n// export const printChildFV = (lambda: LambdaExpr) => {\r\n//     console.log(\"\\n\");\r\n//     console.log(childFVsToString(lambda));\r\n// };\r\n\r\nexport const appBranches = <App extends Application>(\r\n    app: App\r\n): [func: App[\"func\"], arg: App[\"arg\"]] => {\r\n    return [app.func, app.arg];\r\n};\r\n\r\n//Later I'll make a lambdaEq function that uses alpha equality but for now, we'll stick to variable equality since it is simple\r\nexport const varEq = (x: Variable, y: Variable) => {\r\n    return x.name === y.name;\r\n};\r\n\r\nexport const varIn = (x: Variable, vars: Variable[]) => {\r\n    const varNames = new Set(vars.map((v) => v.name));\r\n    return varNames.has(x.name);\r\n};\r\n\r\n//e.g.,    [a, a_1, a_2]\r\nexport const filterVarsByName = (vars: Variable[], name: string) => {\r\n    name = name.replace(regexEndsWithVarNumber, \"\");\r\n\r\n    let toKeep: Set<Variable> = new Set();\r\n\r\n    vars.forEach(\r\n        (x) =>\r\n            //string either is name or it starts with name and ends with variable number pattern.\r\n            (x.name === name ||\r\n                (x.name.startsWith(name) &&\r\n                    regexEndsWithVarNumber.test(x.name))) &&\r\n            toKeep.add(x.name === name ? Var(`${name}_0`, true) : x)\r\n    );\r\n\r\n    return [...toKeep];\r\n};\r\n\r\nexport const getFreshVar = (vars: Variable[], name: string) => {\r\n    name = name.replace(regexEndsWithVarNumber, \"\");\r\n    const current = filterVarsByName(vars, name);\r\n\r\n    const currentNumbers = current\r\n        .map((x) => Number(x.name.slice(x.name.lastIndexOf(\"_\") + 1)))\r\n        .sort();\r\n\r\n    let firstGap: number;\r\n    let prevNum: number = 0;\r\n    for (let index = 0; index < currentNumbers.length; index++) {\r\n        const num = currentNumbers[index];\r\n\r\n        if (num - prevNum > 1) {\r\n            firstGap = prevNum + 1;\r\n            break;\r\n        }\r\n        prevNum = num;\r\n    }\r\n    firstGap = firstGap! ?? prevNum + 1;\r\n\r\n    return Var(name + \"_\" + firstGap, true);\r\n};\r\n\r\nconst getChildNodes = mkLambdaFn<LambdaExpr[], never[]>({\r\n    variable() {\r\n        return [] as Variable[];\r\n    },\r\n    abstraction(abs) {\r\n        return [abs.body] as Abstraction[];\r\n    },\r\n    application(app) {\r\n        return [app.func, app.arg] as Application[];\r\n    },\r\n});\r\n\r\nexport const substitutionMethods: LambdaMethods<\r\n    LambdaExpr,\r\n    [replacementExpr: LambdaExpr, varToReplace: Variable]\r\n> = {\r\n    variable: (variable, _, replacementExpr, varToReplace) => {\r\n        return varEq(variable, varToReplace) ? replacementExpr : variable;\r\n    },\r\n    abstraction: (abs, inner, replacementExpr, varToReplace) => {\r\n        //A.K.A.: The hard part!\r\n        const { boundVar } = abs;\r\n\r\n        let replacementChildFreeVars = [\r\n            replacementExpr,\r\n            ...getChildNodes(replacementExpr),\r\n        ]\r\n            .map((c) => getFreeVars(c))\r\n            .reduce((a, b) => [...a, ...b], []);\r\n\r\n        const body = abs.body;\r\n\r\n        //Set up variables\r\n        let freshBody: LambdaExpr = body;\r\n        let freshVar: Variable = abs.boundVar;\r\n        if (varEq(boundVar, varToReplace)) {\r\n            //The bound variable of the abstraction shadows the variable to replace so we do no substitution\r\n            return abs;\r\n        } else if (\r\n            ///Does not meet freshness condition\r\n            varIn(boundVar, replacementChildFreeVars)\r\n        ) {\r\n            //The fresh var should be distinct from the bound variables in replacement. It's okay if it is the same as an inner bound variable since it will just be shadowed as normal.\r\n            freshVar = getFreshVar(replacementChildFreeVars, boundVar.name);\r\n\r\n            //This has to be done on the body because it will be skipped in substitution if it is done on the abstraction with that bound var\r\n            freshBody = inner(body, freshVar, boundVar);\r\n        }\r\n\r\n        const replacedBody = inner(freshBody, replacementExpr, varToReplace);\r\n\r\n        return abstraction(freshVar, replacedBody);\r\n        //Do I have to deal with updating the lists of free variables!\r\n        //Maybe no since they'll get build up through replacement\r\n    },\r\n    application: (app, inner, replacementExpr, varToReplace) => {\r\n        const [func, arg] = appBranches(app);\r\n        return application(\r\n            inner(func, replacementExpr, varToReplace),\r\n            inner(arg, replacementExpr, varToReplace)\r\n        );\r\n    },\r\n};\r\n\r\nexport const substitute = mkLambdaFn(substitutionMethods);\r\n\r\nexport const alphaEq = (\r\n    lambda1: LambdaExpr,\r\n    lambda2: LambdaExpr,\r\n    boundVarCount: number = 0\r\n): Boolean => {\r\n    if (isAbs(lambda1) && isAbs(lambda2)) {\r\n        const canonicalBoundVar = Var(\"\" + boundVarCount, true);\r\n        const body1 = lambda1.body;\r\n        const body2 = lambda2.body;\r\n        const newBody1 = substitute(body1, canonicalBoundVar, lambda1.boundVar);\r\n        const newBody2 = substitute(body2, canonicalBoundVar, lambda2.boundVar);\r\n        console.log(\"1.\");\r\n        printExpr(lambda1);\r\n        printExpr(newBody1);\r\n        console.log(2);\r\n        printExpr(lambda2);\r\n        printExpr(newBody2);\r\n        return alphaEq(newBody1, newBody2, boundVarCount + 1);\r\n    } else if (isApp(lambda1) && isApp(lambda2)) {\r\n        const [func1, arg1] = appBranches(lambda1);\r\n        const [func2, arg2] = appBranches(lambda2);\r\n        return (\r\n            alphaEq(func1, func2, boundVarCount) &&\r\n            alphaEq(arg1, arg2, boundVarCount)\r\n        );\r\n    } else if (isVar(lambda1) && isVar(lambda2)) {\r\n        return lambda1.name === lambda2.name;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\n//This type defines a beta reducible lambda expression\r\ntype Redex = Application & {\r\n    func: Abstraction;\r\n};\r\n\r\nconst isRedex = (lambda: LambdaExpr): lambda is Redex => {\r\n    if (isApp(lambda)) {\r\n        const [func, arg] = appBranches(lambda);\r\n        if (isAbs(func)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nexport const betaStep = (redex: Redex) => {\r\n    const { func, arg } = redex;\r\n    const body = func.body;\r\n    return substitute(body, arg, func.boundVar);\r\n};\r\n\r\nexport const betaReduce = (lambda: LambdaExpr, maxSteps = 20) => {\r\n    const tracker = { hasBeenReduced: false, count: 0 };\r\n\r\n    const inner = (lambda: LambdaExpr): LambdaExpr => {\r\n        if (isRedex(lambda)) {\r\n            console.log(\"redex:        \", lambdaToString(lambda));\r\n            tracker.hasBeenReduced = true;\r\n            const reduced = betaStep(lambda);\r\n            console.log(\"reduced redex:\", lambdaToString(reduced));\r\n            return betaStep(lambda);\r\n        } else if (isApp(lambda)) {\r\n            const [func, arg] = appBranches(lambda);\r\n            return application(inner(func), inner(arg));\r\n        } else if (isAbs(lambda)) {\r\n            const body = lambda.body;\r\n            return abstraction(lambda.boundVar, inner(body));\r\n        } else if (isVar(lambda)) {\r\n            return lambda;\r\n        }\r\n        let x: never = lambda;\r\n        return x;\r\n    };\r\n\r\n    let current = lambda;\r\n    while (\r\n        tracker.count === 0 ||\r\n        (tracker.hasBeenReduced === true && tracker.count < maxSteps)\r\n    ) {\r\n        tracker.hasBeenReduced = false;\r\n\r\n        current = inner(current);\r\n\r\n        tracker.count = tracker.count + 1;\r\n        if (tracker.count === maxSteps) {\r\n            console.log(\"max steps reached\");\r\n        }\r\n    }\r\n    return current;\r\n};\r\n\r\n// To do\r\n// Make get free vars function rather than tracking free vars in children\r\n// Simpilifies the structure of many functions, allows mapping directly over children expressions\r\n// Make a nicer interface for building expressions\r\n\r\nexport const app = (...lambdas: LambdaExpr[]): Application => {\r\n    return lambdas.reduce((a, b) => {\r\n        return application(a, b);\r\n    }) as Application;\r\n};\r\n\r\nexport function var_(names: string, numberingAllowed?: boolean): Variable;\r\nexport function var_(names: string[], numberingAllowed?: boolean): Variable[];\r\nexport function var_(\r\n    names: string | string[],\r\n    numberingAllowed = false\r\n): Variable | Variable[] {\r\n    if (typeof names === \"string\") {\r\n        return Var(names, numberingAllowed);\r\n    }\r\n    if (names.length === 0) {\r\n        throw new Error(\"Empty array passed to variable constructor.\");\r\n    } else {\r\n        const variables: Variable[] = names.map((name) =>\r\n            Var(name, numberingAllowed)\r\n        );\r\n        return [...new Set(variables)];\r\n    }\r\n}\r\n\r\nexport function abs(\r\n    variables: Variable | Variable[] | string | string[],\r\n    expression: LambdaExpr,\r\n    visualOrder = true\r\n) {\r\n    let vars: Variable[];\r\n    if (typeof variables === \"string\") {\r\n        vars = [Var(variables)];\r\n    } else if (Array.isArray(variables) && variables.length === 0) {\r\n        //Abstracting in no variables is just leaving the expression unchanged\r\n        return expression;\r\n    } else if (Array.isArray(variables) && typeof variables[0] === \"string\") {\r\n        vars = var_(variables as string[]);\r\n    } else if (Array.isArray(variables)) {\r\n        vars = variables as Variable[];\r\n    } else {\r\n        vars = [variables];\r\n    }\r\n\r\n    // Visual order means that the array elements have the same order as the visual output after abstraction\r\n\r\n    // e.g.,\r\n    // \u03BB(x).[(\u03BB(y).[(w)(y)])(x)]\r\n    // visual order => [\"x\", \"y\"]\r\n    // construction order => [\"y\", \"x\"]\r\n\r\n    // Visual order is the reverse of the order of construction of iterated abstraction\r\n    visualOrder && vars.reverse();\r\n\r\n    let result = expression;\r\n    vars.forEach((x) => {\r\n        result = abstraction(x, result);\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\nexport const lam = {\r\n    Var: var_,\r\n    abs,\r\n    app,\r\n    alphaEq,\r\n    betaReduce,\r\n    isVar,\r\n    isAbs,\r\n    isApp,\r\n    lambdaToString,\r\n    printExpr,\r\n    mkLambdaFn,\r\n};\r\n", "import { lam } from \"../classicNamedCalculus\";\r\n\r\nconst { Var, app, abs, printExpr, betaReduce } = lam;\r\n\r\nconst z = Var(\"z\");\r\nconst x = Var(\"x\");\r\nconst y = Var(\"y\");\r\nconst w = Var(\"w\");\r\n\r\nconst xy = app(x, y);\r\nconst absX = abs(x, xy);\r\n\r\n// printExpr(x);\r\n// printExpr(xy);\r\n// printExpr(absX);\r\n\r\nconst xz = app(x, z);\r\nconst xw = app(x, w);\r\nconst xyxz = app(xy, xz);\r\nconst xyxzAbs = abs(x, xyxz);\r\nconst xyxzAbsAbs = abs(y, xyxzAbs);\r\n\r\nconst toReduce1 = app(absX, w);\r\n// printExpr(toReduce1);\r\n// printExpr(betaReduce(toReduce1));\r\n// printExpr(xyxzAbs);\r\n// console.log(getBoundVars(xyxzAbsAbs));\r\n\r\nconst toReduce2 = app(xyxzAbsAbs, x); //That is wrong\r\n\r\nprintExpr(toReduce2);\r\nconst reduced2 = betaReduce(toReduce2);\r\nprintExpr(reduced2);\r\nconsole.log(\"\\n\\n\");\r\n// (\u03BB(y).[\u03BB(x).[((x)(y))((x)(z))]])(x)\r\n// \u03BB(x).[((x)(x))((x)(z))]\r\n// Error, the x has gotten captured\r\n\r\nconst toReduce3 = app(xyxzAbsAbs, abs(w, app(x, y)), x);\r\nprintExpr(toReduce3);\r\nprintExpr(betaReduce(toReduce3));\r\n"],
  "mappings": "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",
  "names": ["x", "lambda", "x", "abs", "app", "app", "x", "y", "abs", "lambda", "Var", "app", "abs", "printExpr", "betaReduce"]
}
