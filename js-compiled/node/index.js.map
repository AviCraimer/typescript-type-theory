{
  "version": 3,
  "sources": ["../../episodes/e02-substitution/classicNamedCalculus.ts", "../../episodes/e02-substitution/index.ts"],
  "sourcesContent": ["//New as of May 17 2023\r\n\r\ntype LambdaExpr = Abstraction | Variable | Application;\r\n\r\ntype LambdaChild<L extends LambdaExpr = LambdaExpr> = {\r\n    childFreeVars: Variable[]; //Used to check if a variable is fresh for a replacement\r\n    childExpr: L;\r\n};\r\n\r\ntype BaseLambda<M extends {}> = {\r\n    children: LambdaChild[];\r\n    meta: M; // Pass in metalanguage info which can be used to add types, etc.\r\n};\r\n\r\ntype Variable<M extends { syntax: \"variable\" } = { syntax: \"variable\" }> =\r\n    BaseLambda<M> & {\r\n        name: string;\r\n        children: never[];\r\n    };\r\n\r\ntype Abstraction<\r\n    M extends { syntax: \"abstraction\" } = { syntax: \"abstraction\" }\r\n> = BaseLambda<M> & {\r\n    boundVar: Variable;\r\n    children: [body: LambdaChild];\r\n};\r\n\r\ntype Application<\r\n    M extends { syntax: \"application\" } = { syntax: \"application\" }\r\n> = BaseLambda<M> & {\r\n    children: [func: LambdaChild, argument: LambdaChild];\r\n};\r\n\r\nexport const isVar = (x: LambdaExpr): x is Variable => {\r\n    if (x.meta.syntax === \"variable\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nexport const isAbs = (x: LambdaExpr): x is Abstraction => {\r\n    if (x.meta.syntax === \"abstraction\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nexport const isApp = (x: LambdaExpr): x is Application => {\r\n    if (x.meta.syntax === \"application\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nlet regexEndsWithVarNumber = /_\\d+$/;\r\n\r\n//Constructs a free variable\r\n//By default it cannot end with an underscore followed by numbers.\r\nexport const Var = (name: string, numberingAllowed = false): Variable => {\r\n    if (\r\n        !numberingAllowed &&\r\n        regexEndsWithVarNumber.test(name) &&\r\n        name.endsWith(\"_\")\r\n    ) {\r\n        throw Error(\r\n            `You tried to create a new variable with a disallowed name: ${name}`\r\n        );\r\n    }\r\n\r\n    return {\r\n        meta: { syntax: \"variable\" },\r\n        name,\r\n        children: [],\r\n    };\r\n};\r\n\r\nconst deduplicateVariables = (vars: Variable[]) => {\r\n    const obj: { [x in string]: Variable } = {};\r\n    vars.forEach((v) => (obj[v.name] = v));\r\n    return Object.values(obj);\r\n};\r\n\r\nexport const excludeVariables = (\r\n    varList: Variable[],\r\n    varsToRemove: Variable[]\r\n) => {\r\n    const toRemoveNames: Set<string> = new Set();\r\n    varsToRemove.forEach((v) => toRemoveNames.add(v.name));\r\n    return varList.filter((v) => !toRemoveNames.has(v.name));\r\n};\r\n\r\nconst getChildFreeVars = (child: LambdaExpr) => {\r\n    if (isVar(child)) {\r\n        return [child];\r\n    } else if (isAbs(child)) {\r\n        const { boundVar } = child;\r\n\r\n        //All variables free in the body of the abstraction are free in the abstraction except the bound variable\r\n        return excludeVariables(child.children[0].childFreeVars, [boundVar]);\r\n    } else if (isApp(child)) {\r\n        const funcVars = child.children[0].childFreeVars;\r\n        const argVars = child.children[1].childFreeVars;\r\n        return deduplicateVariables([...funcVars, ...argVars]);\r\n    }\r\n    let x: never = child;\r\n    return child;\r\n};\r\n\r\nexport const getBoundVars = (child: LambdaExpr): Variable[] => {\r\n    if (isVar(child)) {\r\n        return [];\r\n    } else if (isAbs(child)) {\r\n        const { boundVar } = child;\r\n\r\n        return deduplicateVariables([\r\n            boundVar,\r\n            ...getBoundVars(child.children[0].childExpr),\r\n        ]);\r\n    } else if (isApp(child)) {\r\n        const [func, arg] = appBranches(child);\r\n\r\n        const funcVars = getBoundVars(func);\r\n        const argVars = getBoundVars(arg);\r\n\r\n        return deduplicateVariables([...funcVars, ...argVars]);\r\n    }\r\n    let x: never = child;\r\n    return child;\r\n};\r\n\r\nexport const abstraction = (\r\n    variable: Variable,\r\n    lambda: LambdaExpr\r\n): Abstraction => {\r\n    return {\r\n        meta: { syntax: \"abstraction\" },\r\n        boundVar: variable,\r\n        children: [\r\n            {\r\n                childExpr: lambda,\r\n                childFreeVars: getChildFreeVars(lambda),\r\n            },\r\n        ],\r\n    };\r\n};\r\n\r\nexport const application = (\r\n    first: LambdaExpr,\r\n    second: LambdaExpr\r\n): Application => {\r\n    return {\r\n        meta: { syntax: \"application\" },\r\n        children: [\r\n            {\r\n                childExpr: first,\r\n                childFreeVars: getChildFreeVars(first),\r\n            },\r\n            {\r\n                childExpr: second,\r\n                childFreeVars: getChildFreeVars(second),\r\n            },\r\n        ],\r\n    };\r\n};\r\n\r\ntype LambdaMethods<Return, Args extends unknown[]> = {\r\n    variable: (\r\n        x: Variable,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n    application: (\r\n        x: Application,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n    abstraction: (\r\n        x: Abstraction,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n};\r\n\r\n//<I extends LambdaExpr, R extends LambdaExpr>\r\nconst mkLambdaFn =\r\n    <Return, Args extends unknown[]>(fns: LambdaMethods<Return, Args>) =>\r\n    (lambda: LambdaExpr, ...args: Args) => {\r\n        const inner = (lambda: LambdaExpr, ...innerArgs: Args | []): Return => {\r\n            const extraArgs = (innerArgs.length ? innerArgs : args) as Args;\r\n\r\n            if (isVar(lambda)) {\r\n                return fns.variable(lambda, inner, ...extraArgs);\r\n            } else if (isApp(lambda)) {\r\n                return fns.application(lambda, inner, ...extraArgs);\r\n            } else if (isAbs(lambda)) {\r\n                return fns.abstraction(lambda, inner, ...extraArgs);\r\n            }\r\n            let x: never = lambda;\r\n            return lambda;\r\n        };\r\n\r\n        return inner(lambda);\r\n    };\r\n\r\nexport const lambdaToStringMethods: LambdaMethods<string, []> = {\r\n    variable: (variable) => {\r\n        return variable.name;\r\n    },\r\n    abstraction: (abs, inner) => {\r\n        const body = abs.children[0].childExpr;\r\n        const bodyStr = inner(body);\r\n\r\n        return `\u03BB(${inner(abs.boundVar)}).[${bodyStr}]`;\r\n    },\r\n    application: (app, inner) => {\r\n        return `(${inner(app.children[0].childExpr)})(${inner(\r\n            app.children[1].childExpr\r\n        )})`;\r\n    },\r\n};\r\n\r\nexport const lambdaToString = mkLambdaFn(lambdaToStringMethods);\r\n\r\nexport const printExpr = (lambdaExp: LambdaExpr) => {\r\n    // console.log(\"\\n\");\r\n    console.log(lambdaToString(lambdaExp));\r\n};\r\n\r\nexport const childFVToString = (childExpr: LambdaChild) => {\r\n    return childExpr.childFreeVars.map((v) => lambdaToString(v)).join(\", \");\r\n};\r\n\r\nexport const childFVsToString = (lambda: LambdaExpr) => {\r\n    return lambda.children\r\n        .map(\r\n            (c, i) => (i > 0 ? \"\\n\" : \"\") + `child ${i}: ` + childFVToString(c)\r\n        )\r\n        .join(\"\");\r\n};\r\n\r\nexport const printChildFV = (lambda: LambdaExpr) => {\r\n    console.log(\"\\n\");\r\n    console.log(childFVsToString(lambda));\r\n};\r\n\r\nexport const appBranches = (\r\n    app: Application\r\n): [func: LambdaExpr, arg: LambdaExpr] => {\r\n    return [app.children[0].childExpr, app.children[1].childExpr];\r\n};\r\n\r\n//Later I'll make a lambdaEq function that uses alpha equality but for now, we'll stick to variable equality since it is simple\r\nexport const varEq = (x: Variable, y: Variable) => {\r\n    return x.name === y.name;\r\n};\r\n\r\nexport const varIn = (x: Variable, vars: Variable[]) => {\r\n    const varNames = new Set(vars.map((v) => v.name));\r\n    return varNames.has(x.name);\r\n};\r\n\r\n//e.g.,    [a, a_1, a_2]\r\nexport const filterVarsByName = (vars: Variable[], name: string) => {\r\n    name = name.replace(regexEndsWithVarNumber, \"\");\r\n\r\n    let toKeep: Set<Variable> = new Set();\r\n\r\n    vars.forEach(\r\n        (x) =>\r\n            //string either is name or it starts with name and ends with variable number pattern.\r\n            (x.name === name ||\r\n                (x.name.startsWith(name) &&\r\n                    regexEndsWithVarNumber.test(x.name))) &&\r\n            toKeep.add(x.name === name ? Var(`${name}_0`, true) : x)\r\n    );\r\n\r\n    return [...toKeep];\r\n};\r\n\r\nexport const getFreshVar = (vars: Variable[], name: string) => {\r\n    name = name.replace(regexEndsWithVarNumber, \"\");\r\n    const current = filterVarsByName(vars, name);\r\n\r\n    const currentNumbers = current\r\n        .map((x) => Number(x.name.slice(x.name.lastIndexOf(\"_\") + 1)))\r\n        .sort();\r\n\r\n    let firstGap: number;\r\n    let prevNum: number = 0;\r\n    for (let index = 0; index < currentNumbers.length; index++) {\r\n        const num = currentNumbers[index];\r\n\r\n        if (num - prevNum > 1) {\r\n            firstGap = prevNum + 1;\r\n            break;\r\n        }\r\n        prevNum = num;\r\n    }\r\n    firstGap = firstGap! ?? prevNum + 1;\r\n\r\n    return Var(name + \"_\" + firstGap, true);\r\n};\r\n\r\nexport const substitutionMethods: LambdaMethods<\r\n    LambdaExpr,\r\n    [replacementExpr: LambdaExpr, varToReplace: Variable]\r\n> = {\r\n    variable: (variable, _, replacementExpr, varToReplace) => {\r\n        return varEq(variable, varToReplace) ? replacementExpr : variable;\r\n    },\r\n    abstraction: (abs, inner, replacementExpr, varToReplace) => {\r\n        const { boundVar } = abs;\r\n\r\n        let replacementChildFreeVars = replacementExpr.children\r\n            .map((c) => c.childFreeVars)\r\n            .reduce((a, b) => [...a, ...b], []);\r\n\r\n        const body = abs.children[0].childExpr;\r\n\r\n        let freshBody: LambdaExpr = body;\r\n\r\n        let freshVar: Variable = abs.boundVar;\r\n        if (varEq(boundVar, varToReplace)) {\r\n            //The bound variable of the abstraction shadows the variable to replace so we do no substitution\r\n            return abs;\r\n        } else if (\r\n            ///Does not meet freshness condition\r\n            varIn(boundVar, replacementChildFreeVars)\r\n        ) {\r\n            //The fresh var should be distinct from the bound variables in replacement. It's okay if it is the same as an inner bound variale since it will just be shadowed as normal.\r\n            freshVar = getFreshVar(replacementChildFreeVars, boundVar.name);\r\n\r\n            //This has to be done on the body because it will be skipped in substitution if it is done on the abstraction with that bound var\r\n            freshBody = inner(body, freshVar, boundVar);\r\n        }\r\n\r\n        const replacedBody = inner(freshBody, replacementExpr, varToReplace);\r\n\r\n        return abstraction(freshVar, replacedBody);\r\n        //Do I have to deal with updating the lists of free variables!\r\n        //Maybe no since they'll get build up through replacement\r\n    },\r\n    application: (app, inner, replacementExpr, varToReplace) => {\r\n        const [func, arg] = appBranches(app);\r\n        return application(\r\n            inner(func, replacementExpr, varToReplace),\r\n            inner(arg, replacementExpr, varToReplace)\r\n        );\r\n    },\r\n};\r\n\r\nexport const substitute = mkLambdaFn(substitutionMethods);\r\n\r\n// const subBoundMethods: LambdaMethods<\r\n//     LambdaExpr,\r\n//     [boundVarToReplace: BoundVarSubExpr, replacement: LambdaExpr]\r\n// > = {\r\n//     boundVar: (lambda, _, boundVarToReplace, replacement) => {\r\n//         if (lambda === boundVarToReplace) {\r\n//             return replacement;\r\n//         } else {\r\n//             return lambda;\r\n//         }\r\n//     },\r\n//     freeVar: (lambda) => {\r\n//         return lambda;\r\n//     },\r\n//     application: (lambda, inner) => {\r\n//         return application(inner(lambda.argument), inner(lambda.func));\r\n//     },\r\n//     abstraction: (lambda, inner, boundVarToReplace) => {\r\n//         if (lambda.boundVar === boundVarToReplace) {\r\n//             //We don't substitute into inner lambdas with the same bound variable name, since the variables are always bound to the nearest lambda with the same name. This is called 'variable shadowing' in programming.\r\n//             return lambda;\r\n//         } else {\r\n//             return {\r\n//                 ...lambda,\r\n//                 body: inner(lambda),\r\n//             };\r\n//         }\r\n//     },\r\n//     substitution: (lambda) => {\r\n//         //Not sure what are the algebraic laws of substituting into a substitution\r\n\r\n//         //TODO to do TBD\r\n//         return lambda;\r\n//     },\r\n// };\r\n\r\n// export const subForBound = mkLambdaFn(subBoundMethods);\r\n\r\ntype Redex = Application & {\r\n    children: [LambdaChild<Abstraction>, LambdaChild];\r\n};\r\n\r\n//A beta reducible lambda expression is called a redex\r\n// const isRedex = (lambda: LambdaExpr): lambda is Redex => {\r\n//     return isApp(lambda) && isAbs(lambda.func);\r\n// };\r\n\r\n// const betaStepMethods: LambdaMethods<LambdaExpr, []> = {\r\n//     boundVar: (lambda) => {\r\n//         return lambda;\r\n//     },\r\n//     freeVar: (lambda) => {\r\n//         return lambda;\r\n//     },\r\n//     application: (lambda, inner) => {\r\n//         if (isRedex(lambda)) {\r\n//             const abs = lambda.func;\r\n\r\n//             return subForBound(abs.body, abs.boundVar, lambda.argument);\r\n//         } else {\r\n//             return application;\r\n//         }\r\n//     },\r\n//     abstraction: (lambda, inner) => {\r\n//         return {\r\n//             ...lambda,\r\n//             body: inner(lambda),\r\n//         };\r\n//     },\r\n//     substitution: (lambda) => {\r\n//         //Not sure what are the algebraic laws of substituting into a substitution\r\n\r\n//         //TODO to do TBD\r\n//         return lambda;\r\n//     },\r\n// };\r\n\r\n// export const betaStep = mkLambdaFn(betaStepMethods); //Need to test it!!\r\n\r\n// export const betaReduce = (lambda: LambdaExpr, maxSteps = 10, log = true) => {\r\n//     let count = 0;\r\n//     let prev: LambdaExpr = lambda;\r\n\r\n//     while (count < maxSteps) {\r\n//         const current = betaStep(lambda);\r\n\r\n//         printExpr(prev);\r\n\r\n//         if (lambdaToString(current) === lambdaToString(prev)) {\r\n//             return current;\r\n//         }\r\n//         prev = current;\r\n//         count++;\r\n//     }\r\n\r\n//     console.log(\"max steps reached in beta reduce\");\r\n// };\r\n\r\n//Turning each expression into strings without using bound variable names (only numbers) then comparing.\r\n// export const alphaEq = (expr1: LambdaExpression, expr2: LambdaExpression) => {\r\n//     return lambdaToString(expr1, false) === lambdaToString(expr2, fa);\r\n// };\r\n\r\n//For episode 03\r\n//source: https://sookocheff.com/post/fp/evaluating-lambda-expressions/\r\n\r\n// export const boundVarSubstitution = (\r\n//     abs: AbsExpr,\r\n//     argument: LambdaExpr\r\n// ): LambdaExpr => {\r\n//     const { lambda } = abs;\r\n//     const { binderNumber, body } = lambda;\r\n\r\n//     // Naively without any re-numbering\r\n//     const inner = (current: LambdaExpr): LambdaExpr => {\r\n//         if (typeof current === \"string\") {\r\n//             return current;\r\n//         } else if (typeof current === \"number\") {\r\n//             return current === binderNumber ? argument : current;\r\n//         } else if (\"func\" in current) {\r\n//             return {\r\n//                 func: inner(current.func),\r\n//                 argument: inner(current.argument),\r\n//             };\r\n//         } else if (\"binderNumber\" in current) {\r\n//             return {\r\n//                 ...current,\r\n//                 body: inner(current.body),\r\n//             };\r\n//         }\r\n//         let x: never = current;\r\n//         return x;\r\n//     };\r\n//     return inner(body);\r\n// };\r\n\r\n//Iterative evaluation by substitution\r\n//Normal Order, evaluates functions from left to right and from outer most to inner most.\r\n//Think of it as evaluating functions first, before evaluating the arguments to a function\r\n\r\n//Note: My numbering system is different from de Bruijn numbering. That uses the distance from the binding lambda to the bound variables so that different instances of the same  bound variables in an expression are represented with different numbes. A way to think of this is that each bound variable token is like a map telling you how to find it's binder from where it is in the expression. The binder itself does not have any number associated with it.\r\n", "import {\r\n    abstraction,\r\n    application,\r\n    Var,\r\n    varEq,\r\n    varIn,\r\n    printExpr,\r\n    substitute,\r\n    getChildBoundVars,\r\n    printChildFV,\r\n    filterVarsByName,\r\n    excludeVariables,\r\n    lambdaToString,\r\n    getFreshVar,\r\n    // subForBound,\r\n    // boundVariableString,\r\n    // betaStep,\r\n    // betaReduce,\r\n} from \"./classicNamedCalculus\";\r\nconsole.log(\"\\n\".repeat(6));\r\n\r\nconst x = Var(\"x\");\r\nconst x1 = Var(\"x_1\", true);\r\nconst x134 = Var(\"x__134\", true);\r\nconst y = Var(\"y\");\r\nconst z = Var(\"z\");\r\nconst w = Var(\"w\");\r\n\r\n// console.log(excludeVariables([x, y, z], [x, w, z]));\r\n\r\nconst xy = application(x, y);\r\nconst absX = abstraction(x, xy);\r\n\r\n// printExpr(x);\r\n// printExpr(xy);\r\n// printExpr(absX);\r\n\r\nconst xz = application(x, z);\r\nconst xyxz = application(xy, xz);\r\nconst xyxzAbs = abstraction(x, xyxz);\r\nconst xyxzAbsAbs = abstraction(x, xyxzAbs);\r\n\r\n// printExpr(xyxzAbs);\r\n// console.log(getChildBoundVars(xyxzAbsAbs));\r\nprintExpr(xyxzAbsAbs);\r\n\r\nconst sub1 = substitute(xyxzAbsAbs, xyxz, y);\r\n\r\nprintExpr(sub1);\r\n\r\n// printChildFV(xyxzAbs);\r\n\r\n// console.log(getFreshVar([x1, x, y, x134, x, z], \"x\"));\r\n\r\n// const sub = subForBound(absX.body, boundVariableString(x), xyxz);\r\n\r\n// printExpr(absX);\r\n// printExpr(sub);\r\n// printExpr(absX);\r\n\r\n// const absY = abstraction(\"y\", xy);\r\n// const absYY = application(y, absY);\r\n\r\n// const xz = application(x, z);\r\n// const absZ = abstraction(\"z\", xz);\r\n// const absZZ = application(z, absZ);\r\n// const absZZZ = abstraction(\"z\", absZZ);\r\n\r\n// //Demonstrates non-capture\r\n// const absYYY = abstraction(\"y\", absYY);\r\n// //Prints as \u03BB(\u02DAy_2).[(\u03BB(\u02DAy_1).[(x)(\u02DAy_1)])(\u02DAy_2)]\r\n// //Notice the second abstraction over y does not capture the bound variable \u02DAy_1\r\n\r\n// // const id1 = abstraction(\"x\", x);\r\n// // const trivAbs = abstraction(\"x\", y);\r\n// // console.log(x);\r\n// // console.log(y);\r\n// // console.log(absX);\r\n// // console.log(JSON.stringify(xy, , 2));\r\n// // console.log(absX);\r\n// printExpr(absX);\r\n// printExpr(absY);\r\n// printExpr(absYYY);\r\n// printExpr(absZZZ);\r\n// printExpr(absYYY, false);\r\n\r\n// const subZ = boundVarSubstitution(absYYY, z.lambda);\r\n\r\n// console.log(subExprToString(subZ));\r\n"],
  "mappings": "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",
  "names": ["x", "lambda", "x", "x", "y"]
}
