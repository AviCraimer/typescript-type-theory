{
  "version": 3,
  "sources": ["../../episodes/e03-de-bruijn-numbering/index.ts"],
  "sourcesContent": ["import { Lambda } from \"../e02-lambda-reduction/lambdaExpressions\";\r\n\r\nconsole.log(\"De Bruijn Numbering\");\r\n\r\nexport type Lambda = Variable | Application | Abstraction;\r\n\r\ntype RootLambda = Lambda & {\r\n    freeVars: string[];\r\n    toString: () => string;\r\n    isRoot: true;\r\n};\r\n\r\ntype EmbeddedLambda = Lambda & {\r\n    rootLambda: RootLambda;\r\n    isRoot: false;\r\n};\r\n\r\nexport type Variable = {\r\n    readonly role: \"Variable\";\r\n    referenceNum: number;\r\n};\r\n\r\nexport type Application = {\r\n    readonly role: \"Application\";\r\n    func: EmbeddedLambda;\r\n    argument: EmbeddedLambda;\r\n};\r\n\r\nexport type Abstraction = {\r\n    readonly role: \"Abstraction\";\r\n    body: EmbeddedLambda;\r\n};\r\n\r\nexport const apply = (...args: Lambda[]): Application => {\r\n    if (args.length < 2) {\r\n        throw new Error(\"Cannot apply with fewer than two lambda arguments\");\r\n    }\r\n\r\n    const applyOnce = (func: Lambda, argument: Lambda): Application => {\r\n        return {\r\n            role: \"Application\",\r\n            func,\r\n            argument,\r\n            toString,\r\n        };\r\n    };\r\n\r\n    let current = applyOnce(args[0], args[1]);\r\n\r\n    args.forEach((arg, i) => {\r\n        if (i > 1) {\r\n            current = applyOnce(current, arg);\r\n        }\r\n    });\r\n\r\n    return current;\r\n};\r\n\r\n// console.log(apply(x, y, apply(z, w)).toString());\r\n\r\n// Any object we can form that fits this type will be a valid lambda expression.\r\nfunction toString(this: Abstraction | Application): string {\r\n    if (this.role === \"Abstraction\") {\r\n        const { parameter, body } = this;\r\n        return `[ \u03BB${parameter} . ${body.toString()} ]`;\r\n    } else if (this.role === \"Application\") {\r\n        const { func, argument } = this;\r\n        return `${func.toString()} (${argument.toString()})`;\r\n    }\r\n    const nothing: never = this;\r\n    return nothing;\r\n}\r\n\r\n//To create an abstraction we need substitution.\r\nexport const substitution = (\r\n    expression: Lambda,\r\n    replace: Variable,\r\n    substitute: Lambda | VariableBound\r\n): Lambda => {\r\n    if (typeof expression === \"string\") {\r\n        //Variable\r\n        if (expression === replace) {\r\n            if (!isBound(replace) && !isBound(substitute)) {\r\n                throw new Error(\r\n                    \"You can only replace a free variable with a bound variable.\"\r\n                );\r\n            }\r\n\r\n            return substitute;\r\n        } else {\r\n            //Otherwise return it unmodified\r\n            return expression;\r\n        }\r\n    } else if (expression.role === \"Abstraction\") {\r\n        const { parameter, body } = expression;\r\n\r\n        return {\r\n            ...expression,\r\n            parameter:\r\n                isBound(substitute) && replace === expression.parameter\r\n                    ? (substitute as VariableBound)\r\n                    : expression.parameter,\r\n            body: substitution(body, replace, substitute),\r\n        };\r\n    } else if (expression.role === \"Application\") {\r\n        //Application\r\n        const { func, argument } = expression;\r\n\r\n        return {\r\n            ...expression,\r\n            func: substitution(func, replace, substitute),\r\n            argument: substitution(argument, replace, substitute),\r\n        };\r\n    }\r\n    const nothing: never = expression; //So TypeScript knows undefined will never be implicitly returned by the function.\r\n    return nothing;\r\n};\r\n\r\nexport const abstract = (\r\n    variable: FreeVariable,\r\n    expression: Lambda\r\n): Abstraction => {\r\n    const parameter = Var(variable, false);\r\n    const body = substitution(expression, variable, parameter);\r\n\r\n    return {\r\n        role: \"Abstraction\",\r\n        parameter,\r\n        body,\r\n        toString,\r\n    };\r\n};\r\n\r\nexport const print = (...objs: any[]) => {\r\n    objs.forEach((obj) => console.log(obj.toString()));\r\n};\r\n\r\nexport {};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,QAAQ,IAAI;AA+BL,IAAM,QAAQ,IAAI,SAAgC;AACrD,MAAI,KAAK,SAAS,GAAG;AACjB,UAAM,IAAI,MAAM;AAAA;AAGpB,QAAM,YAAY,CAAC,MAAc,aAAkC;AAC/D,WAAO;AAAA,MACH,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAIR,MAAI,UAAU,UAAU,KAAK,IAAI,KAAK;AAEtC,OAAK,QAAQ,CAAC,KAAK,MAAM;AACrB,QAAI,IAAI,GAAG;AACP,gBAAU,UAAU,SAAS;AAAA;AAAA;AAIrC,SAAO;AAAA;AAMX,oBAA2D;AACvD,MAAI,KAAK,SAAS,eAAe;AAC7B,UAAM,EAAE,WAAW,SAAS;AAC5B,WAAO,WAAM,eAAe,KAAK;AAAA,aAC1B,KAAK,SAAS,eAAe;AACpC,UAAM,EAAE,MAAM,aAAa;AAC3B,WAAO,GAAG,KAAK,eAAe,SAAS;AAAA;AAE3C,QAAM,UAAiB;AACvB,SAAO;AAAA;AAIJ,IAAM,eAAe,CACxB,YACA,SACA,eACS;AACT,MAAI,OAAO,eAAe,UAAU;AAEhC,QAAI,eAAe,SAAS;AACxB,UAAI,CAAC,QAAQ,YAAY,CAAC,QAAQ,aAAa;AAC3C,cAAM,IAAI,MACN;AAAA;AAIR,aAAO;AAAA,WACJ;AAEH,aAAO;AAAA;AAAA,aAEJ,WAAW,SAAS,eAAe;AAC1C,UAAM,EAAE,WAAW,SAAS;AAE5B,WAAO,iCACA,aADA;AAAA,MAEH,WACI,QAAQ,eAAe,YAAY,WAAW,YACvC,aACD,WAAW;AAAA,MACrB,MAAM,aAAa,MAAM,SAAS;AAAA;AAAA,aAE/B,WAAW,SAAS,eAAe;AAE1C,UAAM,EAAE,MAAM,aAAa;AAE3B,WAAO,iCACA,aADA;AAAA,MAEH,MAAM,aAAa,MAAM,SAAS;AAAA,MAClC,UAAU,aAAa,UAAU,SAAS;AAAA;AAAA;AAGlD,QAAM,UAAiB;AACvB,SAAO;AAAA;AAGJ,IAAM,WAAW,CACpB,UACA,eACc;AACd,QAAM,YAAY,IAAI,UAAU;AAChC,QAAM,OAAO,aAAa,YAAY,UAAU;AAEhD,SAAO;AAAA,IACH,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAID,IAAM,QAAQ,IAAI,SAAgB;AACrC,OAAK,QAAQ,CAAC,QAAQ,QAAQ,IAAI,IAAI;AAAA;",
  "names": []
}
