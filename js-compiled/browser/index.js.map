{
  "version": 3,
  "sources": ["../../episodes/TBD01-lambda-substitution/classicNamedCalculus.ts", "../../episodes/TBD01-lambda-substitution/demo.ts", "../../episodes/TBD01-lambda-substitution/index.ts"],
  "sourcesContent": ["//New as of May 17 2023\r\n\r\nexport type LambdaExpr = Abstraction | Variable | Application;\r\n\r\nexport type LambdaChild<L extends LambdaExpr = LambdaExpr> = {\r\n    childFreeVars: Variable[]; //Used to check if a variable is fresh for a replacement\r\n    childExpr: L;\r\n};\r\n\r\nexport type BaseLambda<Meta extends {}> = {\r\n    children: LambdaChild[];\r\n    syntax: string; // Indicates the kind of syntax represented by the object\r\n} & Meta; // Pass in metalanguage info which can be used to add types, etc.;\r\n\r\nexport type Variable<Meta extends {} = {}> = BaseLambda<{\r\n    syntax: \"variable\";\r\n    name: string;\r\n    children: never[];\r\n}> &\r\n    Meta;\r\n\r\nexport type Abstraction<Meta extends {} = {}> = BaseLambda<{\r\n    syntax: \"abstraction\";\r\n    boundVar: Variable;\r\n    children: [body: LambdaChild];\r\n}> &\r\n    Meta;\r\n\r\nexport type Application<Meta extends {} = {}> = BaseLambda<{\r\n    syntax: \"application\";\r\n    children: [func: LambdaChild, argument: LambdaChild];\r\n}> &\r\n    Meta;\r\n\r\nexport const isVar = (x: LambdaExpr): x is Variable => {\r\n    if (x.syntax === \"variable\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nexport const isAbs = (x: LambdaExpr): x is Abstraction => {\r\n    if (x.syntax === \"abstraction\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nexport const isApp = (x: LambdaExpr): x is Application => {\r\n    if (x.syntax === \"application\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nlet regexEndsWithVarNumber = /_\\d+$/;\r\n\r\n//Constructs a free variable\r\n//By default it cannot end with an underscore followed by numbers.\r\nexport const Var = (name: string, numberingAllowed = false): Variable => {\r\n    if (\r\n        !numberingAllowed &&\r\n        regexEndsWithVarNumber.test(name) &&\r\n        name.endsWith(\"_\")\r\n    ) {\r\n        throw Error(\r\n            `You tried to create a new variable with a disallowed name: ${name}`\r\n        );\r\n    }\r\n\r\n    return {\r\n        syntax: \"variable\",\r\n        name,\r\n        children: [],\r\n    };\r\n};\r\n\r\nconst deduplicateVariables = (vars: Variable[]) => {\r\n    const obj: { [x in string]: Variable } = {};\r\n    vars.forEach((v) => (obj[v.name] = v));\r\n    return Object.values(obj);\r\n};\r\n\r\nexport const excludeVariables = (\r\n    varList: Variable[],\r\n    varsToRemove: Variable[]\r\n) => {\r\n    const toRemoveNames: Set<string> = new Set();\r\n    varsToRemove.forEach((v) => toRemoveNames.add(v.name));\r\n    return varList.filter((v) => !toRemoveNames.has(v.name));\r\n};\r\n\r\nconst getChildFreeVars = (child: LambdaExpr) => {\r\n    if (isVar(child)) {\r\n        return [child];\r\n    } else if (isAbs(child)) {\r\n        const { boundVar } = child;\r\n\r\n        //All variables free in the body of the abstraction are free in the abstraction except the bound variable\r\n        return excludeVariables(child.children[0].childFreeVars, [boundVar]);\r\n    } else if (isApp(child)) {\r\n        const funcVars = child.children[0].childFreeVars;\r\n        const argVars = child.children[1].childFreeVars;\r\n        return deduplicateVariables([...funcVars, ...argVars]);\r\n    }\r\n    let x: never = child;\r\n    return child;\r\n};\r\n\r\nexport const getBoundVars = (child: LambdaExpr): Variable[] => {\r\n    if (isVar(child)) {\r\n        return [];\r\n    } else if (isAbs(child)) {\r\n        const { boundVar } = child;\r\n\r\n        return deduplicateVariables([\r\n            boundVar,\r\n            ...getBoundVars(child.children[0].childExpr),\r\n        ]);\r\n    } else if (isApp(child)) {\r\n        const [func, arg] = appBranches(child);\r\n\r\n        const funcVars = getBoundVars(func);\r\n        const argVars = getBoundVars(arg);\r\n\r\n        return deduplicateVariables([...funcVars, ...argVars]);\r\n    }\r\n    let x: never = child;\r\n    return child;\r\n};\r\n\r\nexport const abstraction = (\r\n    variable: Variable,\r\n    lambda: LambdaExpr\r\n): Abstraction => {\r\n    return {\r\n        syntax: \"abstraction\",\r\n        boundVar: variable,\r\n        children: [\r\n            {\r\n                childExpr: lambda,\r\n                childFreeVars: getChildFreeVars(lambda),\r\n            },\r\n        ],\r\n    };\r\n};\r\n\r\nexport const application = (\r\n    first: LambdaExpr,\r\n    second: LambdaExpr\r\n): Application => {\r\n    return {\r\n        syntax: \"application\",\r\n        children: [\r\n            {\r\n                childExpr: first,\r\n                childFreeVars: getChildFreeVars(first),\r\n            },\r\n            {\r\n                childExpr: second,\r\n                childFreeVars: getChildFreeVars(second),\r\n            },\r\n        ],\r\n    };\r\n};\r\n\r\ntype LambdaMethods<Return, Args extends unknown[]> = {\r\n    variable: (\r\n        x: Variable,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n    application: (\r\n        x: Application,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n    abstraction: (\r\n        x: Abstraction,\r\n        inner: (lambda: LambdaExpr, ...args: Args) => Return,\r\n        ...args: Args\r\n    ) => Return;\r\n};\r\n\r\n//<I extends LambdaExpr, R extends LambdaExpr>\r\nconst mkLambdaFn =\r\n    <Return, Args extends unknown[]>(fns: LambdaMethods<Return, Args>) =>\r\n    (lambda: LambdaExpr, ...args: Args) => {\r\n        const inner = (lambda: LambdaExpr, ...innerArgs: Args | []): Return => {\r\n            const extraArgs = (innerArgs.length ? innerArgs : args) as Args;\r\n\r\n            if (isVar(lambda)) {\r\n                return fns.variable(lambda, inner, ...extraArgs);\r\n            } else if (isApp(lambda)) {\r\n                return fns.application(lambda, inner, ...extraArgs);\r\n            } else if (isAbs(lambda)) {\r\n                return fns.abstraction(lambda, inner, ...extraArgs);\r\n            }\r\n            let x: never = lambda;\r\n            return lambda;\r\n        };\r\n\r\n        return inner(lambda);\r\n    };\r\n\r\nexport const lambdaToStringMethods: LambdaMethods<string, []> = {\r\n    variable: (variable) => {\r\n        return variable.name;\r\n    },\r\n    abstraction: (abs, inner) => {\r\n        const body = abs.children[0].childExpr;\r\n        const bodyStr = inner(body);\r\n\r\n        return `\u03BB(${inner(abs.boundVar)}).[${bodyStr}]`;\r\n    },\r\n    application: (app, inner) => {\r\n        return `(${inner(app.children[0].childExpr)})(${inner(\r\n            app.children[1].childExpr\r\n        )})`;\r\n    },\r\n};\r\n\r\nexport const lambdaToString = mkLambdaFn(lambdaToStringMethods);\r\n\r\nexport const printExpr = (lambdaExp: LambdaExpr) => {\r\n    // console.log(\"\\n\");\r\n    console.log(lambdaToString(lambdaExp));\r\n};\r\n\r\nexport const childFVToString = (childExpr: LambdaChild) => {\r\n    return childExpr.childFreeVars.map((v) => lambdaToString(v)).join(\", \");\r\n};\r\n\r\nexport const childFVsToString = (lambda: LambdaExpr) => {\r\n    return lambda.children\r\n        .map(\r\n            (c, i) => (i > 0 ? \"\\n\" : \"\") + `child ${i}: ` + childFVToString(c)\r\n        )\r\n        .join(\"\");\r\n};\r\n\r\nexport const printChildFV = (lambda: LambdaExpr) => {\r\n    console.log(\"\\n\");\r\n    console.log(childFVsToString(lambda));\r\n};\r\n\r\nexport const appBranches = <App extends Application>(\r\n    app: App\r\n): [\r\n    func: App[\"children\"][0][\"childExpr\"],\r\n    arg: App[\"children\"][1][\"childExpr\"]\r\n] => {\r\n    return [app.children[0].childExpr, app.children[1].childExpr];\r\n};\r\n\r\n//Later I'll make a lambdaEq function that uses alpha equality but for now, we'll stick to variable equality since it is simple\r\nexport const varEq = (x: Variable, y: Variable) => {\r\n    return x.name === y.name;\r\n};\r\n\r\nexport const varIn = (x: Variable, vars: Variable[]) => {\r\n    const varNames = new Set(vars.map((v) => v.name));\r\n    return varNames.has(x.name);\r\n};\r\n\r\n//e.g.,    [a, a_1, a_2]\r\nexport const filterVarsByName = (vars: Variable[], name: string) => {\r\n    name = name.replace(regexEndsWithVarNumber, \"\");\r\n\r\n    let toKeep: Set<Variable> = new Set();\r\n\r\n    vars.forEach(\r\n        (x) =>\r\n            //string either is name or it starts with name and ends with variable number pattern.\r\n            (x.name === name ||\r\n                (x.name.startsWith(name) &&\r\n                    regexEndsWithVarNumber.test(x.name))) &&\r\n            toKeep.add(x.name === name ? Var(`${name}_0`, true) : x)\r\n    );\r\n\r\n    return [...toKeep];\r\n};\r\n\r\nexport const getFreshVar = (vars: Variable[], name: string) => {\r\n    name = name.replace(regexEndsWithVarNumber, \"\");\r\n    const current = filterVarsByName(vars, name);\r\n\r\n    const currentNumbers = current\r\n        .map((x) => Number(x.name.slice(x.name.lastIndexOf(\"_\") + 1)))\r\n        .sort();\r\n\r\n    let firstGap: number;\r\n    let prevNum: number = 0;\r\n    for (let index = 0; index < currentNumbers.length; index++) {\r\n        const num = currentNumbers[index];\r\n\r\n        if (num - prevNum > 1) {\r\n            firstGap = prevNum + 1;\r\n            break;\r\n        }\r\n        prevNum = num;\r\n    }\r\n    firstGap = firstGap! ?? prevNum + 1;\r\n\r\n    return Var(name + \"_\" + firstGap, true);\r\n};\r\n\r\nexport const substitutionMethods: LambdaMethods<\r\n    LambdaExpr,\r\n    [replacementExpr: LambdaExpr, varToReplace: Variable]\r\n> = {\r\n    variable: (variable, _, replacementExpr, varToReplace) => {\r\n        return varEq(variable, varToReplace) ? replacementExpr : variable;\r\n    },\r\n    abstraction: (abs, inner, replacementExpr, varToReplace) => {\r\n        //A.K.A.: The hard part!\r\n        const { boundVar } = abs;\r\n\r\n        let replacementChildFreeVars = replacementExpr.children\r\n            .map((c) => c.childFreeVars)\r\n            .reduce((a, b) => [...a, ...b], []);\r\n\r\n        const body = abs.children[0].childExpr;\r\n\r\n        let freshBody: LambdaExpr = body;\r\n\r\n        let freshVar: Variable = abs.boundVar;\r\n        if (varEq(boundVar, varToReplace)) {\r\n            //The bound variable of the abstraction shadows the variable to replace so we do no substitution\r\n            return abs;\r\n        } else if (\r\n            ///Does not meet freshness condition\r\n            varIn(boundVar, replacementChildFreeVars)\r\n        ) {\r\n            //The fresh var should be distinct from the bound variables in replacement. It's okay if it is the same as an inner bound variable since it will just be shadowed as normal.\r\n            freshVar = getFreshVar(replacementChildFreeVars, boundVar.name);\r\n\r\n            //This has to be done on the body because it will be skipped in substitution if it is done on the abstraction with that bound var\r\n            freshBody = inner(body, freshVar, boundVar);\r\n        }\r\n\r\n        const replacedBody = inner(freshBody, replacementExpr, varToReplace);\r\n\r\n        return abstraction(freshVar, replacedBody);\r\n        //Do I have to deal with updating the lists of free variables!\r\n        //Maybe no since they'll get build up through replacement\r\n    },\r\n    application: (app, inner, replacementExpr, varToReplace) => {\r\n        const [func, arg] = appBranches(app);\r\n        return application(\r\n            inner(func, replacementExpr, varToReplace),\r\n            inner(arg, replacementExpr, varToReplace)\r\n        );\r\n    },\r\n};\r\n\r\nexport const substitute = mkLambdaFn(substitutionMethods);\r\n\r\nexport const alphaEq = (\r\n    lambda1: LambdaExpr,\r\n    lambda2: LambdaExpr,\r\n    boundVarCount: number = 0\r\n): Boolean => {\r\n    if (isAbs(lambda1) && isAbs(lambda2)) {\r\n        const canonicalBoundVar = Var(\"\" + boundVarCount, true);\r\n        const body1 = lambda1.children[0].childExpr;\r\n        const body2 = lambda2.children[0].childExpr;\r\n        const newBody1 = substitute(body1, canonicalBoundVar, lambda1.boundVar);\r\n        const newBody2 = substitute(body2, canonicalBoundVar, lambda2.boundVar);\r\n        console.log(\"1.\");\r\n        printExpr(lambda1);\r\n        printExpr(newBody1);\r\n        console.log(2);\r\n        printExpr(lambda2);\r\n        printExpr(newBody2);\r\n        return alphaEq(newBody1, newBody2, boundVarCount + 1);\r\n    } else if (isApp(lambda1) && isApp(lambda2)) {\r\n        const [func1, arg1] = appBranches(lambda1);\r\n        const [func2, arg2] = appBranches(lambda2);\r\n        return (\r\n            alphaEq(func1, func2, boundVarCount) &&\r\n            alphaEq(arg1, arg2, boundVarCount)\r\n        );\r\n    } else if (isVar(lambda1) && isVar(lambda2)) {\r\n        return lambda1.name === lambda2.name;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\n//This type defines a beta reducible lambda expression\r\ntype Redex = Application & {\r\n    children: [LambdaChild<Abstraction>, LambdaChild];\r\n};\r\n\r\nconst isRedex = (lambda: LambdaExpr): lambda is Redex => {\r\n    if (isApp(lambda)) {\r\n        const [func, arg] = appBranches(lambda);\r\n        if (isAbs(func)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nexport const betaStep = (redex: Redex) => {\r\n    const [func, arg] = appBranches(redex);\r\n    const body = func.children[0].childExpr;\r\n    return substitute(body, arg, func.boundVar);\r\n};\r\n\r\nexport const betaReduce = (lambda: LambdaExpr, maxSteps = 20) => {\r\n    const tracker = { hasBeenReduced: false, count: 0 };\r\n\r\n    const inner = (lambda: LambdaExpr): LambdaExpr => {\r\n        if (isRedex(lambda)) {\r\n            tracker.hasBeenReduced = true;\r\n            return betaStep(lambda);\r\n        } else if (isApp(lambda)) {\r\n            const [func, arg] = appBranches(lambda);\r\n            return application(inner(func), inner(arg));\r\n        } else if (isAbs(lambda)) {\r\n            const body = lambda.children[0].childExpr;\r\n            return abstraction(lambda.boundVar, inner(body));\r\n        } else if (isVar(lambda)) {\r\n            return lambda;\r\n        }\r\n        let x: never = lambda;\r\n        return x;\r\n    };\r\n\r\n    let current = lambda;\r\n    while (\r\n        tracker.count === 0 ||\r\n        (tracker.hasBeenReduced === true && tracker.count < maxSteps)\r\n    ) {\r\n        tracker.hasBeenReduced = false;\r\n\r\n        current = inner(current);\r\n\r\n        tracker.count = tracker.count + 1;\r\n        if (tracker.count === maxSteps) {\r\n            console.log(\"max steps reached\");\r\n        }\r\n    }\r\n    return current;\r\n};\r\n\r\n// To do\r\n// Make get free vars function rather than tracking free vars in children\r\n// Simpilifies the structure of many functions, allows mapping directly over children expressions\r\n// Make a nicer interface for building expressions\r\n\r\nexport const app = (...lambdas: LambdaExpr[]): Application => {\r\n    return lambdas.reduce((a, b) => {\r\n        return application(a, b);\r\n    }) as Application;\r\n};\r\n\r\nexport function var_(names: string, numberingAllowed?: boolean): Variable;\r\nexport function var_(names: string[], numberingAllowed?: boolean): Variable[];\r\nexport function var_(\r\n    names: string | string[],\r\n    numberingAllowed = false\r\n): Variable | Variable[] {\r\n    if (typeof names === \"string\") {\r\n        return Var(names, numberingAllowed);\r\n    }\r\n    if (names.length === 0) {\r\n        throw new Error(\"Empty array passed to variable constructor.\");\r\n    } else {\r\n        const variables: Variable[] = names.map((name) =>\r\n            Var(name, numberingAllowed)\r\n        );\r\n        return [...new Set(variables)];\r\n    }\r\n}\r\n\r\nexport function abs(\r\n    variables: Variable | Variable[] | string | string[],\r\n    expression: LambdaExpr,\r\n    visualOrder = true\r\n) {\r\n    let vars: Variable[];\r\n    if (typeof variables === \"string\") {\r\n        vars = [Var(variables)];\r\n    } else if (Array.isArray(variables) && variables.length === 0) {\r\n        //Abstracting in no variables is just leaving the expression unchanged\r\n        return expression;\r\n    } else if (Array.isArray(variables) && typeof variables[0] === \"string\") {\r\n        vars = var_(variables as string[]);\r\n    } else if (Array.isArray(variables)) {\r\n        vars = variables as Variable[];\r\n    } else {\r\n        vars = [variables];\r\n    }\r\n\r\n    // Visual order means that the array elements have the same order as the visual output after abstraction\r\n\r\n    // e.g.,\r\n    // \u03BB(x).[(\u03BB(y).[(w)(y)])(x)]\r\n    // visual order => [\"x\", \"y\"]\r\n    // construction order => [\"y\", \"x\"]\r\n\r\n    // Visual order is the reverse of the order of construction of iterated abstraction\r\n    visualOrder && vars.reverse();\r\n\r\n    let result = expression;\r\n    vars.forEach((x) => {\r\n        result = abstraction(x, result);\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\nexport const lam = {\r\n    Var: var_,\r\n    abs,\r\n    app,\r\n    alphaEq,\r\n    betaReduce,\r\n    isVar,\r\n    isAbs,\r\n    isApp,\r\n    lambdaToString,\r\n};\r\n", "import {\r\n    abstraction,\r\n    application,\r\n    Var,\r\n    varEq,\r\n    varIn,\r\n    printExpr,\r\n    substitute,\r\n    alphaEq,\r\n    getBoundVars,\r\n    printChildFV,\r\n    filterVarsByName,\r\n    excludeVariables,\r\n    lambdaToString,\r\n    getFreshVar,\r\n    betaReduce,\r\n    subForBound,\r\n    boundVariableString,\r\n    betaStep,\r\n    betaReduce,\r\n} from \"./classicNamedCalculus\";\r\n\r\nexport default function demo() {}\r\nconsole.log(\"\\n\".repeat(6));\r\n\r\nconst x = Var(\"x\");\r\nconst x1 = Var(\"x_1\", true);\r\nconst x134 = Var(\"x__134\", true);\r\nconst y = Var(\"y\");\r\nconst z = Var(\"z\");\r\nconst w = Var(\"w\");\r\n\r\nconsole.log(excludeVariables([x, y, z], [x, z]));\r\n\r\nconst xy = application(x, y);\r\nconst absX = abstraction(x, xy);\r\n\r\nprintExpr(x);\r\nprintExpr(xy);\r\nprintExpr(absX);\r\n\r\nconst xz = application(x, z);\r\nconst xw = application(x, w);\r\nconst xyxz = application(xy, xz);\r\nconst xyxzAbs = abstraction(x, xyxz);\r\nconst xyxzAbsAbs = abstraction(x, xyxzAbs);\r\n\r\nprintExpr(absX);\r\nprintExpr(substitute(absX.children[0].childExpr, w, x));\r\nprintExpr(xyxzAbs);\r\nconsole.log(getBoundVars(xyxzAbsAbs));\r\nprintExpr(xyxzAbsAbs);\r\n\r\n// // const sub1 = substitute(xyxzAbsAbs, xyxz, y);\r\n// // printExpr(sub1);\r\n// const A1 = abstraction(z, application(abstraction(x, xz), Var(\"f\")));\r\n// const A2 = abstraction(x, abstraction(z, xz));\r\n// const B1 = abstraction(z, xz);\r\n// const B2 = abstraction(w, xw);\r\n\r\n// // printExpr(B1);\r\n// // printExpr(B2);\r\n\r\n// printExpr(A1);\r\n// // printExpr(application(A1, Var(\"f\")));\r\n// const R1 = betaReduce(A1);\r\n\r\n// printExpr(R1);\r\n// // console.log(alphaEq(B1, B2)); // Comes out true but it shouldn't\r\n\r\n// // printExpr(sub1);\r\n\r\n// // printChildFV(xyxzAbs);\r\n\r\n// // console.log(getFreshVar([x1, x, y, x134, x, z], \"x\"));\r\n\r\n// // const sub = subForBound(absX.body, boundVariableString(x), xyxz);\r\n\r\n// // printExpr(absX);\r\n// // printExpr(sub);\r\n// // printExpr(absX);\r\n\r\n// // const absY = abstraction(\"y\", xy);\r\n// // const absYY = application(y, absY);\r\n\r\n// // const xz = application(x, z);\r\n// // const absZ = abstraction(\"z\", xz);\r\n// // const absZZ = application(z, absZ);\r\n// // const absZZZ = abstraction(\"z\", absZZ);\r\n\r\n// // //Demonstrates non-capture\r\n// // const absYYY = abstraction(\"y\", absYY);\r\n// // //Prints as \u03BB(\u02DAy_2).[(\u03BB(\u02DAy_1).[(x)(\u02DAy_1)])(\u02DAy_2)]\r\n// // //Notice the second abstraction over y does not capture the bound variable \u02DAy_1\r\n\r\n// // // const id1 = abstraction(\"x\", x);\r\n// // // const trivAbs = abstraction(\"x\", y);\r\n// // // console.log(x);\r\n// // // console.log(y);\r\n// // // console.log(absX);\r\n// // // console.log(JSON.stringify(xy, , 2));\r\n// // // console.log(absX);\r\n// // printExpr(absX);\r\n// // printExpr(absY);\r\n// // printExpr(absYYY);\r\n// // printExpr(absZZZ);\r\n// // printExpr(absYYY, false);\r\n\r\n// // const subZ = boundVarSubstitution(absYYY, z.lambda);\r\n\r\n// // console.log(subExprToString(subZ));\r\n", "import demo from \"./demo\";\r\n\r\nexport { lam } from \"./classicNamedCalculus\";\r\n\r\nexport type {\r\n    LambdaExpr,\r\n    Variable,\r\n    Application,\r\n    Abstraction,\r\n    BaseLambda,\r\n} from \"./classicNamedCalculus\";\r\n\r\ndemo();\r\n"],
  "mappings": "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",
  "names": ["x", "lambda", "abs", "app", "app", "x", "y", "abs", "lambda"]
}
