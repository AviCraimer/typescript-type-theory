{
  "version": 3,
  "sources": ["../../episodes/e03-de-bruijn-numbering/index.ts"],
  "sourcesContent": ["import { Lambda } from \"../e02-lambda-reduction/lambdaExpressions\";\r\n\r\nconsole.log(\"De Bruijn Numbering\");\r\n\r\nexport type Lambda = Variable | Application | Abstraction;\r\n\r\ntype RootLambda = Lambda & {\r\n    freeVars: string[];\r\n    toString: () => string;\r\n    isRoot: true;\r\n};\r\n\r\ntype EmbeddedLambda = Lambda & {\r\n    rootLambda: RootLambda;\r\n    isRoot: false;\r\n};\r\n\r\nexport type Variable = {\r\n    readonly role: \"Variable\";\r\n    referenceNum: number;\r\n};\r\n\r\nexport type Application = {\r\n    readonly role: \"Application\";\r\n    func: EmbeddedLambda;\r\n    argument: EmbeddedLambda;\r\n};\r\n\r\nexport type Abstraction = {\r\n    readonly role: \"Abstraction\";\r\n    body: EmbeddedLambda;\r\n};\r\n\r\nexport const apply = (...args: Lambda[]): Application => {\r\n    if (args.length < 2) {\r\n        throw new Error(\"Cannot apply with fewer than two lambda arguments\");\r\n    }\r\n\r\n    const applyOnce = (func: Lambda, argument: Lambda): Application => {\r\n        return {\r\n            role: \"Application\",\r\n            func,\r\n            argument,\r\n            toString,\r\n        };\r\n    };\r\n\r\n    let current = applyOnce(args[0], args[1]);\r\n\r\n    args.forEach((arg, i) => {\r\n        if (i > 1) {\r\n            current = applyOnce(current, arg);\r\n        }\r\n    });\r\n\r\n    return current;\r\n};\r\n\r\n// console.log(apply(x, y, apply(z, w)).toString());\r\n\r\n// Any object we can form that fits this type will be a valid lambda expression.\r\nfunction toString(this: Abstraction | Application): string {\r\n    if (this.role === \"Abstraction\") {\r\n        const { parameter, body } = this;\r\n        return `[ \u03BB${parameter} . ${body.toString()} ]`;\r\n    } else if (this.role === \"Application\") {\r\n        const { func, argument } = this;\r\n        return `${func.toString()} (${argument.toString()})`;\r\n    }\r\n    const nothing: never = this;\r\n    return nothing;\r\n}\r\n\r\n//To create an abstraction we need substitution.\r\nexport const substitution = (\r\n    expression: Lambda,\r\n    replace: Variable,\r\n    substitute: Lambda | VariableBound\r\n): Lambda => {\r\n    if (typeof expression === \"string\") {\r\n        //Variable\r\n        if (expression === replace) {\r\n            if (!isBound(replace) && !isBound(substitute)) {\r\n                throw new Error(\r\n                    \"You can only replace a free variable with a bound variable.\"\r\n                );\r\n            }\r\n\r\n            return substitute;\r\n        } else {\r\n            //Otherwise return it unmodified\r\n            return expression;\r\n        }\r\n    } else if (expression.role === \"Abstraction\") {\r\n        const { parameter, body } = expression;\r\n\r\n        return {\r\n            ...expression,\r\n            parameter:\r\n                isBound(substitute) && replace === expression.parameter\r\n                    ? (substitute as VariableBound)\r\n                    : expression.parameter,\r\n            body: substitution(body, replace, substitute),\r\n        };\r\n    } else if (expression.role === \"Application\") {\r\n        //Application\r\n        const { func, argument } = expression;\r\n\r\n        return {\r\n            ...expression,\r\n            func: substitution(func, replace, substitute),\r\n            argument: substitution(argument, replace, substitute),\r\n        };\r\n    }\r\n    const nothing: never = expression; //So TypeScript knows undefined will never be implicitly returned by the function.\r\n    return nothing;\r\n};\r\n\r\nexport const abstract = (\r\n    variable: FreeVariable,\r\n    expression: Lambda\r\n): Abstraction => {\r\n    const parameter = Var(variable, false);\r\n    const body = substitution(expression, variable, parameter);\r\n\r\n    return {\r\n        role: \"Abstraction\",\r\n        parameter,\r\n        body,\r\n        toString,\r\n    };\r\n};\r\n\r\nexport const print = (...objs: any[]) => {\r\n    objs.forEach((obj) => console.log(obj.toString()));\r\n};\r\n\r\nexport {};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;AAEA,UAAQ,IAAI;AA+BL,MAAM,QAAQ,IAAI,SAAgC;AACrD,QAAI,KAAK,SAAS,GAAG;AACjB,YAAM,IAAI,MAAM;AAAA;AAGpB,UAAM,YAAY,CAAC,MAAc,aAAkC;AAC/D,aAAO;AAAA,QACH,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAIR,QAAI,UAAU,UAAU,KAAK,IAAI,KAAK;AAEtC,SAAK,QAAQ,CAAC,KAAK,MAAM;AACrB,UAAI,IAAI,GAAG;AACP,kBAAU,UAAU,SAAS;AAAA;AAAA;AAIrC,WAAO;AAAA;AAMX,sBAA2D;AACvD,QAAI,KAAK,SAAS,eAAe;AAC7B,YAAM,EAAE,WAAW,SAAS;AAC5B,aAAO,WAAM,eAAe,KAAK;AAAA,eAC1B,KAAK,SAAS,eAAe;AACpC,YAAM,EAAE,MAAM,aAAa;AAC3B,aAAO,GAAG,KAAK,eAAe,SAAS;AAAA;AAE3C,UAAM,UAAiB;AACvB,WAAO;AAAA;AAIJ,MAAM,eAAe,CACxB,YACA,SACA,eACS;AACT,QAAI,OAAO,eAAe,UAAU;AAEhC,UAAI,eAAe,SAAS;AACxB,YAAI,CAAC,QAAQ,YAAY,CAAC,QAAQ,aAAa;AAC3C,gBAAM,IAAI,MACN;AAAA;AAIR,eAAO;AAAA,aACJ;AAEH,eAAO;AAAA;AAAA,eAEJ,WAAW,SAAS,eAAe;AAC1C,YAAM,EAAE,WAAW,SAAS;AAE5B,aAAO,iCACA,aADA;AAAA,QAEH,WACI,QAAQ,eAAe,YAAY,WAAW,YACvC,aACD,WAAW;AAAA,QACrB,MAAM,aAAa,MAAM,SAAS;AAAA;AAAA,eAE/B,WAAW,SAAS,eAAe;AAE1C,YAAM,EAAE,MAAM,aAAa;AAE3B,aAAO,iCACA,aADA;AAAA,QAEH,MAAM,aAAa,MAAM,SAAS;AAAA,QAClC,UAAU,aAAa,UAAU,SAAS;AAAA;AAAA;AAGlD,UAAM,UAAiB;AACvB,WAAO;AAAA;AAGJ,MAAM,WAAW,CACpB,UACA,eACc;AACd,UAAM,YAAY,IAAI,UAAU;AAChC,UAAM,OAAO,aAAa,YAAY,UAAU;AAEhD,WAAO;AAAA,MACH,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAID,MAAM,QAAQ,IAAI,SAAgB;AACrC,SAAK,QAAQ,CAAC,QAAQ,QAAQ,IAAI,IAAI;AAAA;",
  "names": []
}
