{
  "version": 3,
  "sources": ["../../episodes/TBD03-linear-logic-relations/linear-logic-of-relations/src/logic/syntaxTree.ts", "../../episodes/TBD03-linear-logic-relations/linear-logic-of-relations/src/logic/examples/operationChecking.ts"],
  "sourcesContent": ["const unaryOps = {\r\n    neg: \"\u00AC\",\r\n    converse: \"\u2AEF\",\r\n    linNeg: \"~\",\r\n} as const;\r\n\r\nconst binaryOps = {\r\n    par: \"\u214B\", // \"\u2AA4\",\r\n    comp: \"\u25B8\",\r\n    and: \"&\",\r\n    or: \"\u2228\",\r\n    linImp: \"\u22B8\",\r\n    linImpLeft: \"\u27DC\",\r\n    imp: \"\u2283\",\r\n} as const;\r\n\r\n//TODO\r\n// const nAryOps = {\r\n//     and: \"&\",\r\n//     or: \"\u2228\",\r\n// };\r\n\r\ntype BinaryOpName = keyof typeof binaryOps;\r\ntype UnaryOpName = keyof typeof unaryOps;\r\ntype OpName = BinaryOpName | UnaryOpName;\r\n\r\nconst allOps: {\r\n    [opName in OpName]: opName extends BinaryOpName\r\n        ? (typeof binaryOps)[opName]\r\n        : opName extends UnaryOpName\r\n        ? (typeof unaryOps)[opName]\r\n        : never;\r\n} = {\r\n    ...unaryOps,\r\n    ...binaryOps,\r\n} as const;\r\n\r\ntype AllOps = typeof allOps;\r\n\r\ntype AtomicRelation = {\r\n    type: \"atomic relation\";\r\n    name: string;\r\n    converseName: string;\r\n};\r\n\r\nconst atom = (name: string, converse: string): AtomicRelation => {\r\n    return {\r\n        type: \"atomic relation\",\r\n        name,\r\n        converseName: converse,\r\n    };\r\n};\r\n\r\ntype Relation = AtomicRelation | CompositeRelation;\r\n\r\ntype CompositeRelation = UnaryComposite | BinaryComposite;\r\ntype Operation = UnaryOp | BinaryOp;\r\n\r\ntype UnaryOp = (typeof unaryOps)[keyof typeof unaryOps];\r\n\r\ntype UnaryComposite = {\r\n    type: \"composite\";\r\n    operation: UnaryOp;\r\n    children: [Relation];\r\n};\r\n\r\ntype BinaryOp = (typeof binaryOps)[keyof typeof binaryOps];\r\n\r\ntype BinaryComposite = {\r\n    type: \"composite\";\r\n    operation: BinaryOp;\r\n    children: [Relation, Relation];\r\n};\r\n\r\ntype SpecificComp<Op extends Operation> = CompositeRelation & {\r\n    operation: Op;\r\n};\r\n\r\nexport type SpecificComp2<\r\n    Outer extends UnaryOp,\r\n    Inner extends Operation\r\n> = SpecificComp<Outer> & {\r\n    children: [SpecificComp<Inner>];\r\n};\r\n\r\nexport type SpecificComp3<\r\n    Outer extends UnaryOp,\r\n    Inner1 extends UnaryOp,\r\n    Inner2 extends Operation\r\n> = SpecificComp<Outer> & {\r\n    children: [SpecificComp2<Inner1, Inner2>];\r\n};\r\n\r\nconst isOp =\r\n    <Op extends Operation>(op: Op) =>\r\n    (relation: Relation): relation is SpecificComp<Op> => {\r\n        return \"children\" in relation && relation.operation === op;\r\n    };\r\n\r\nconst opCheck: {\r\n    [opName in OpName]: (\r\n        relation: Relation\r\n    ) => relation is SpecificComp<AllOps[opName]>;\r\n} = {\r\n    par: isOp(allOps.par),\r\n    comp: isOp(allOps.comp),\r\n    and: isOp(allOps.and),\r\n    or: isOp(allOps.or),\r\n    linImp: isOp(allOps.linImp),\r\n    linImpLeft: isOp(allOps.linImpLeft),\r\n    imp: isOp(allOps.imp),\r\n    neg: isOp(allOps.neg),\r\n    converse: isOp(allOps.converse),\r\n    linNeg: isOp(allOps.linNeg),\r\n};\r\n\r\nconst opCheckLevel2 =\r\n    <Outer extends UnaryOpName, Inner extends OpName>(\r\n        outer: Outer,\r\n        inner: Inner\r\n    ) =>\r\n    (rel: Relation): rel is SpecificComp2<AllOps[Outer], AllOps[Inner]> => {\r\n        if (isAtomic(rel)) {\r\n            return false;\r\n        }\r\n\r\n        return opCheck[outer](rel) && opCheck[inner](rel.children[0]);\r\n    };\r\n\r\nconst opCheckBranch =\r\n    <\r\n        Outer extends BinaryOpName,\r\n        InnerLeft extends OpName | \"\",\r\n        InnerRight extends OpName | \"\"\r\n    >(\r\n        outer: Outer,\r\n        innerLeft: InnerLeft,\r\n        innerRight: InnerRight\r\n    ) =>\r\n    (\r\n        rel: Relation\r\n    ): rel is SpecificComp<AllOps[Outer]> & {\r\n        children: [\r\n            InnerLeft extends \"\"\r\n                ? Relation\r\n                : InnerLeft extends OpName\r\n                ? SpecificComp<AllOps[InnerLeft]>\r\n                : never,\r\n            InnerRight extends \"\"\r\n                ? Relation\r\n                : InnerRight extends OpName\r\n                ? SpecificComp<AllOps[InnerRight]>\r\n                : never\r\n        ];\r\n    } => {\r\n        if (isAtomic(rel) || !opCheck[outer](rel)) {\r\n            return false;\r\n        }\r\n        const left =\r\n            innerLeft === \"\"\r\n                ? true\r\n                : opCheck[innerLeft as OpName](rel.children[0]);\r\n        const right =\r\n            innerRight === \"\"\r\n                ? true\r\n                : opCheck[innerRight as OpName](rel.children[1]!); // This ! is justified because we know the outer operation is binary\r\n        return left && right;\r\n    };\r\n\r\nconst opCheckLevel3 =\r\n    <\r\n        Outer extends UnaryOpName,\r\n        Inner1 extends UnaryOpName,\r\n        Inner2 extends OpName\r\n    >(\r\n        outer: Outer,\r\n        inner1: Inner1,\r\n        inner2: Inner2\r\n    ) =>\r\n    (\r\n        rel: Relation\r\n    ): rel is SpecificComp3<AllOps[Outer], AllOps[Inner1], AllOps[Inner2]> => {\r\n        if (isAtomic(rel)) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            opCheck[outer](rel) &&\r\n            opCheck[inner1](rel.children[0]) &&\r\n            opCheck[inner2](rel.children[0].children[0])\r\n        );\r\n    };\r\n\r\ntype RelationCheck<R extends Relation> = (rel: Relation) => rel is R;\r\n\r\nconst unionChecks = <R1 extends Relation, R2 extends Relation>(\r\n    a: RelationCheck<R1>,\r\n    b: RelationCheck<R2>\r\n): RelationCheck<R1 | R2> => {\r\n    return (rel: Relation): rel is R1 | R2 => a(rel) || b(rel);\r\n};\r\n\r\nconst intersectChecks = <R1 extends Relation, R2 extends Relation>(\r\n    a: RelationCheck<R1>,\r\n    b: RelationCheck<R2>\r\n): RelationCheck<R1 & R2> => {\r\n    return (rel: Relation): rel is R1 & R2 => a(rel) && b(rel);\r\n};\r\n\r\nconst isAtomic = (relation: Relation): relation is AtomicRelation => {\r\n    if (relation.type === \"atomic relation\") {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nconst isUnary = (relation: Relation): relation is UnaryComposite => {\r\n    if (\r\n        !isAtomic(relation) &&\r\n        Object.values(unaryOps).includes(relation.operation as UnaryOp)\r\n    ) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nconst isBinary = (relation: Relation): relation is BinaryComposite => {\r\n    if (\r\n        !isAtomic(relation) &&\r\n        Object.values(binaryOps).includes(relation.operation as BinaryOp)\r\n    ) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n};\r\n\r\nconst applyUnary =\r\n    <Op extends UnaryOp>(op: Op) =>\r\n    (relation: Relation): SpecificComp<Op> => {\r\n        return {\r\n            type: \"composite\",\r\n            operation: op,\r\n            children: [relation],\r\n        };\r\n    };\r\n\r\nconst applyBinary =\r\n    <Op extends BinaryOp>(op: Op) =>\r\n    (...relations: [Relation, Relation]): SpecificComp<Op> => {\r\n        return {\r\n            type: \"composite\",\r\n            operation: op,\r\n            children: [...relations],\r\n        };\r\n    };\r\n\r\ntype ApplyOp<Op extends Operation> = (\r\n    ...relations: SpecificComp<Op>[\"children\"]\r\n) => SpecificComp<Op>;\r\n\r\nconst opApp: {\r\n    [opName in keyof AllOps]: ApplyOp<AllOps[opName]>;\r\n} = {\r\n    par: applyBinary(allOps.par),\r\n    comp: applyBinary(allOps.comp),\r\n    and: applyBinary(allOps.and),\r\n    or: applyBinary(allOps.or),\r\n    linImp: applyBinary(allOps.linImp),\r\n    linImpLeft: applyBinary(allOps.linImpLeft),\r\n    imp: applyBinary(allOps.imp),\r\n    neg: applyUnary(allOps.neg),\r\n    converse: applyUnary(allOps.converse),\r\n    linNeg: applyUnary(allOps.linNeg),\r\n};\r\n\r\nconst toStr = (relation: Relation): string => {\r\n    if (relation.type === \"atomic relation\") {\r\n        return relation.name;\r\n    } else if (\r\n        opCheck.converse(relation) &&\r\n        relation.children[0].type === \"atomic relation\"\r\n    ) {\r\n        return relation.children[0].converseName;\r\n    } else if (isUnary(relation)) {\r\n        return `${relation.operation}(${toStr(relation.children[0])})`;\r\n    } else if (isBinary(relation)) {\r\n        return `(${toStr(relation.children[0])} ${relation.operation} ${toStr(\r\n            relation.children[1]\r\n        )})`;\r\n    }\r\n\r\n    let x: never = relation;\r\n    return relation;\r\n};\r\n\r\nconst printRel = (rel: Relation | undefined) => {\r\n    console.log(rel ? toStr(rel) : \"undefined\");\r\n};\r\n\r\nexport {\r\n    opApp,\r\n    opCheck,\r\n    allOps,\r\n    toStr,\r\n    atom,\r\n    printRel,\r\n    opCheckLevel2,\r\n    opCheckBranch,\r\n    opCheckLevel3,\r\n    unionChecks,\r\n    intersectChecks,\r\n};\r\nexport type { Relation, SpecificComp };\r\n", "import { opApp, atom, opCheckLevel2, opCheckLevel3 } from \"../syntaxTree\";\r\n\r\nconst R = atom(\"R\", \"R\u030C\");\r\nconst S = atom(\"S\", \"S\u030C\");\r\nconst T = atom(\"T\", \"T\u030C\");\r\n\r\nconst negConverseR = opApp.neg(opApp.converse(R));\r\n\r\nconst converseNegR = opApp.converse(opApp.neg(R));\r\n\r\nconst normalForm = opApp.linNeg(R);\r\n\r\nconst converseNegCheck = opCheckLevel2(\"converse\", \"neg\");\r\nconst negConverseCheck = opCheckLevel2(\"neg\", \"converse\");\r\n\r\nconsole.log(converseNegCheck(converseNegR)); // true\r\nconsole.log(negConverseCheck(converseNegR)); // false\r\nconsole.log(negConverseCheck(negConverseR)); // true\r\nconsole.log(converseNegCheck(negConverseR)); // false\r\nconsole.log(converseNegCheck(R)); // false\r\n\r\nconst converseNegCompCheck = opCheckLevel3(\"converse\", \"neg\", \"comp\");\r\n\r\nconst example1 = opApp.converse(opApp.neg(opApp.comp(R, S)));\r\n\r\nconsole.log(converseNegCompCheck(example1)); // true\r\nconsole.log(converseNegCompCheck(converseNegR)); // false\r\nconsole.log(converseNegCompCheck(S)); // false\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA,MAAM,WAAW;AAAA,IACb,KAAK;AAAA,IACL,UAAU;AAAA,IACV,QAAQ;AAAA,EACZ;AAEA,MAAM,YAAY;AAAA,IACd,KAAK;AAAA,IACL,MAAM;AAAA,IACN,KAAK;AAAA,IACL,IAAI;AAAA,IACJ,QAAQ;AAAA,IACR,YAAY;AAAA,IACZ,KAAK;AAAA,EACT;AAYA,MAAM,SAMF,kCACG,WACA;AAWP,MAAM,OAAO,CAAC,MAAc,aAAqC;AAC7D,WAAO;AAAA,MACH,MAAM;AAAA,MACN;AAAA,MACA,cAAc;AAAA,IAClB;AAAA,EACJ;AA0CA,MAAM,OACF,CAAuB,OACvB,CAAC,aAAqD;AAClD,WAAO,cAAc,YAAY,SAAS,cAAc;AAAA,EAC5D;AAEJ,MAAM,UAIF;AAAA,IACA,KAAK,KAAK,OAAO,GAAG;AAAA,IACpB,MAAM,KAAK,OAAO,IAAI;AAAA,IACtB,KAAK,KAAK,OAAO,GAAG;AAAA,IACpB,IAAI,KAAK,OAAO,EAAE;AAAA,IAClB,QAAQ,KAAK,OAAO,MAAM;AAAA,IAC1B,YAAY,KAAK,OAAO,UAAU;AAAA,IAClC,KAAK,KAAK,OAAO,GAAG;AAAA,IACpB,KAAK,KAAK,OAAO,GAAG;AAAA,IACpB,UAAU,KAAK,OAAO,QAAQ;AAAA,IAC9B,QAAQ,KAAK,OAAO,MAAM;AAAA,EAC9B;AAEA,MAAM,gBACF,CACI,OACA,UAEJ,CAAC,QAAsE;AACnE,QAAI,SAAS,GAAG,GAAG;AACf,aAAO;AAAA,IACX;AAEA,WAAO,QAAQ,OAAO,GAAG,KAAK,QAAQ,OAAO,IAAI,SAAS,EAAE;AAAA,EAChE;AA0CJ,MAAM,gBACF,CAKI,OACA,QACA,WAEJ,CACI,QACsE;AACtE,QAAI,SAAS,GAAG,GAAG;AACf,aAAO;AAAA,IACX;AAEA,WACI,QAAQ,OAAO,GAAG,KAClB,QAAQ,QAAQ,IAAI,SAAS,EAAE,KAC/B,QAAQ,QAAQ,IAAI,SAAS,GAAG,SAAS,EAAE;AAAA,EAEnD;AAkBJ,MAAM,WAAW,CAAC,aAAmD;AACjE,QAAI,SAAS,SAAS,mBAAmB;AACrC,aAAO;AAAA,IACX,OAAO;AACH,aAAO;AAAA,IACX;AAAA,EACJ;AAwBA,MAAM,aACF,CAAqB,OACrB,CAAC,aAAyC;AACtC,WAAO;AAAA,MACH,MAAM;AAAA,MACN,WAAW;AAAA,MACX,UAAU,CAAC,QAAQ;AAAA,IACvB;AAAA,EACJ;AAEJ,MAAM,cACF,CAAsB,OACtB,IAAI,cAAsD;AACtD,WAAO;AAAA,MACH,MAAM;AAAA,MACN,WAAW;AAAA,MACX,UAAU,CAAC,GAAG,SAAS;AAAA,IAC3B;AAAA,EACJ;AAMJ,MAAM,QAEF;AAAA,IACA,KAAK,YAAY,OAAO,GAAG;AAAA,IAC3B,MAAM,YAAY,OAAO,IAAI;AAAA,IAC7B,KAAK,YAAY,OAAO,GAAG;AAAA,IAC3B,IAAI,YAAY,OAAO,EAAE;AAAA,IACzB,QAAQ,YAAY,OAAO,MAAM;AAAA,IACjC,YAAY,YAAY,OAAO,UAAU;AAAA,IACzC,KAAK,YAAY,OAAO,GAAG;AAAA,IAC3B,KAAK,WAAW,OAAO,GAAG;AAAA,IAC1B,UAAU,WAAW,OAAO,QAAQ;AAAA,IACpC,QAAQ,WAAW,OAAO,MAAM;AAAA,EACpC;;;AClRA,MAAM,IAAI,KAAK,KAAK,SAAI;AACxB,MAAM,IAAI,KAAK,KAAK,SAAI;AACxB,MAAM,IAAI,KAAK,KAAK,SAAI;AAExB,MAAM,eAAe,MAAM,IAAI,MAAM,SAAS,CAAC,CAAC;AAEhD,MAAM,eAAe,MAAM,SAAS,MAAM,IAAI,CAAC,CAAC;AAEhD,MAAM,aAAa,MAAM,OAAO,CAAC;AAEjC,MAAM,mBAAmB,cAAc,YAAY,KAAK;AACxD,MAAM,mBAAmB,cAAc,OAAO,UAAU;AAExD,UAAQ,IAAI,iBAAiB,YAAY,CAAC;AAC1C,UAAQ,IAAI,iBAAiB,YAAY,CAAC;AAC1C,UAAQ,IAAI,iBAAiB,YAAY,CAAC;AAC1C,UAAQ,IAAI,iBAAiB,YAAY,CAAC;AAC1C,UAAQ,IAAI,iBAAiB,CAAC,CAAC;AAE/B,MAAM,uBAAuB,cAAc,YAAY,OAAO,MAAM;AAEpE,MAAM,WAAW,MAAM,SAAS,MAAM,IAAI,MAAM,KAAK,GAAG,CAAC,CAAC,CAAC;AAE3D,UAAQ,IAAI,qBAAqB,QAAQ,CAAC;AAC1C,UAAQ,IAAI,qBAAqB,YAAY,CAAC;AAC9C,UAAQ,IAAI,qBAAqB,CAAC,CAAC;",
  "names": []
}
